// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;

// Note: this namespace is intentional. From the developers perspective, there isn't a subfolder for partial classes.
namespace Microsoft.Performance.SDK.Processing
{
    /// <summary>
    ///     Contains static (Shared in Visual Basic) methods for creating
    ///     Projections that are useful in a variety of contexts.
    ///     <para/>
    ///     All projections generated by this class properly handle the
    ///     <see cref="IViewportSensitiveProjection"/> interface.
    /// </summary>
    public static partial class Projection
    {
        /// <summary>
        ///     Creates a projection that projects the aggregates all of the data
        ///     produced by the given projection that is visible in the viewport.
        /// </summary>
        /// <typeparam name="T">
        ///     The return <see cref="Type"/> of the projection.
        /// </typeparam>
        /// <typeparam name="TAggregate">
        ///     The <see cref="Type"/> of the aggregated result.
        /// </typeparam>
        /// <param name="projection">
        ///     The projection to aggregate.
        /// </param>
        /// <returns>
        ///     The new projection.
        /// </returns>
        /// <exception cref="System.ArgumentNullException">
        ///     <paramref name="projection"/> is <c>null</c>.
        /// </exception>
        public static IProjection<int, TAggregate> AggregateInViewport<T, TAggregate>(
            IProjection<int, T> projection)
        {
            Guard.NotNull(projection, nameof(projection));

            var typeArgs = new[]
            {
                typeof(T),
                typeof(TAggregate),
                projection.GetType(),
            };

            var constructorArgs = new[]
            {
                projection,
            };

            var type = typeof(AggregateRowsInViewportColumnGenerator<,,>).MakeGenericType(typeArgs);
            var instance = Activator.CreateInstance(type, constructorArgs);

            var aggregation = (IProjection<int, TAggregate>)instance;

            return CacheViewportColumn.Create(aggregation);
        }

        /// <summary>
        ///     Creates a projection that caches the results of its
        ///     computations. The first time the projection is invoked
        ///     for a given integer will compute the value for that
        ///     integer, and subsequent invocations with the same integer
        ///     will always return the cached value.
        /// </summary>
        /// <typeparam name="T">
        ///     The return <see cref="Type"/> of the projection.
        /// </typeparam>
        /// <param name="rowCount">
        ///     Defines the domain of the projection. This is the upper
        ///     bound on the range of integers that can be expected to
        ///     be passed to the projection. This parameter must be
        ///     non-negative.
        /// </param>
        /// <param name="projection">
        ///     The projection whose results are to be cached.
        /// </param>
        /// <returns>
        ///     A new projection that caches the results of 
        ///     <paramref name="projection"/> on their first use.
        /// </returns>
        /// <exception cref="System.ArgumentNullException">
        ///     <paramref name="projection"/> is <c>null</c>.
        /// </exception>
        /// <exception cref="System.ArgumentOutOfRangeException">
        ///     <paramref name="rowCount"/> is less than zero (0.)
        /// </exception>
        public static IProjection<int, T> CacheOnFirstUse<T>(
            int rowCount,
            IProjection<int, T> projection)
        {
            Guard.GreaterThanOrEqualTo(rowCount, 0, nameof(rowCount));
            Guard.NotNull(projection, nameof(projection));

            var typeArgs = new[]
            {
                typeof(T),
                projection.GetType(),
            };

            var constructorArgs = new object[]
            {
                rowCount,
                projection,
            };

            var type = typeof(CachedOnFirstUseColumnGenerator<,>).MakeGenericType(typeArgs);
            var instance = Activator.CreateInstance(type, constructorArgs);
            return (IProjection<int, T>)instance;
        }

        /// <summary>
        ///     Performs a functional composition of the given projection
        ///     with another function.
        ///     <para />
        ///     Let f(x) and g(x) be projections. Then f.Compose(g) will result
        ///     in a projection equivalent to g(f(x)).
        /// </summary>
        /// <typeparam name="T1">
        ///     The <see cref="Type"/> of the input.
        /// </typeparam>
        /// <typeparam name="T2">
        ///     The <see cref="Type"/> of the result of the first projection.
        /// </typeparam>
        /// <typeparam name="TResult">
        ///     The <see cref="Type"/> of the result of the second projection,
        ///     and thus the overall newly created projection.
        /// </typeparam>
        /// <param name="f">
        ///     The first projection in the composition.
        /// </param>
        /// <param name="g">
        ///     The function to compose with <paramref name="f"/>.
        /// </param>
        /// <returns>
        ///     A projection that is the composition of <paramref name="f"/>
        ///     with <paramref name="g"/>.
        /// </returns>
        /// <exception cref="System.ArgumentNullException">
        ///     <paramref name="f"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="g"/> is <c>null</c>.
        /// </exception>
        public static IProjection<T1, TResult> Compose<T1, T2, TResult>(
            this IProjection<T1, T2> f,
            Func<T2, TResult> g)
        {
            Guard.NotNull(f, nameof(f));
            Guard.NotNull(g, nameof(g));

            return IsMethodPubliclyAccessible(g.Method)
                ? f.Compose(Create(g))
                : f.Compose(CreateUsingFuncAdaptor(g));
        }

        /// <summary>
        ///     Performs a functional composition of the given projection
        ///     with another projection.
        ///     <para />
        ///     Let f(x) and g(x) be projections. Then f.Compose(g) will result
        ///     in a projection equivalent to g(f(x)).
        /// </summary>
        /// <typeparam name="T1">
        ///     The <see cref="Type"/> of the input.
        /// </typeparam>
        /// <typeparam name="T2">
        ///     The <see cref="Type"/> of the result of the first projection.
        /// </typeparam>
        /// <typeparam name="TResult">
        ///     The <see cref="Type"/> of the result of the second projection,
        ///     and thus the overall newly created projection.
        /// </typeparam>
        /// <param name="f">
        ///     The first projection in the composition.
        /// </param>
        /// <param name="g">
        ///     The projection to compose with <paramref name="f"/>.
        /// </param>
        /// <returns>
        ///     A projection that is the composition of <paramref name="f"/>
        ///     with <paramref name="g"/>.
        /// </returns>
        /// <exception cref="System.ArgumentNullException">
        ///     <paramref name="f"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="g"/> is <c>null</c>.
        /// </exception>
        public static IProjection<T1, TResult> Compose<T1, T2, TResult>(
            this IProjection<T1, T2> f,
            IProjection<T2, TResult> g)
        {
            Guard.NotNull(f, nameof(f));
            Guard.NotNull(g, nameof(g));

            var typeArgs = new[]
            {
                typeof(T1),
                typeof(T2),
                typeof(TResult),
                f.GetType(),
                g.GetType(),
            };

            var constructorArgs = new object[]
            {
                f,
                g,
            };

            var type = typeof(CompositionProjection<,,,,>).MakeGenericType(typeArgs);
            var instance = Activator.CreateInstance(type, constructorArgs);
            return (IProjection<T1, TResult>)instance;
        }

        /// <summary>
        ///     Creates a projection that always returns the given value,
        ///     regardless of the input.
        /// </summary>
        /// <typeparam name="T">
        ///     The <see cref="Type"/> of <paramref name="value"/>.
        /// </typeparam>
        /// <param name="value">
        ///     The value that should always be returned by the projection.
        /// </param>
        /// <returns>
        ///     A projection that always returns <paramref name="value"/>.
        /// </returns>
        public static IProjection<int, T> Constant<T>(T value)
        {
            return Constant<int, T>(value);
        }

        /// <summary>
        ///     Determines whether the given projection is a constant projection.
        ///     That is, was the projection created with <see cref="Constant{T1, TResult}(TResult)"/>.
        /// </summary>
        /// <typeparam name="T">
        ///     The argument <see cref="Type"/>.
        /// </typeparam>
        /// <typeparam name="TResult">
        ///     The result <see cref="Type"/>.
        /// </typeparam>
        /// <param name="self">
        ///     The <see cref="IProjection{TSource, TResult}"/> to interrogate.
        /// </param>
        /// <returns>
        ///     <c>true</c> if <paramref name="self"/> is constant;
        ///     <c>false</c> otherwise.
        /// </returns>
        public static bool IsConstant<T, TResult>(
            this IProjection<T, TResult> self)
        {
            return self is ConstantProjection<T, TResult>;
        }

        /// <summary>
        ///     Creates a projection that always returns the given value,
        ///     regardless of the input.
        /// </summary>
        /// <typeparam name="T">
        ///     The <see cref="Type"/> of <paramref name="value"/>.
        /// </typeparam>
        /// <typeparam name="TResult">
        ///     The <see cref="Type"/> of the result.
        /// </typeparam>
        /// <param name="value">
        ///     The value that should always be returned by the projection.
        /// </param>
        /// <returns>
        ///     A projection that always returns <paramref name="value"/>.
        /// </returns>
        public static IProjection<T, TResult> Constant<T, TResult>(TResult value)
        {
            return new ConstantProjection<T, TResult>(value);
        }

        /// <summary>
        ///     Creates a projection from the given delegate. The given
        ///     delegate must be a publicly accessible method on a publicly
        ///     accessible class. If you need to create a projection from 
        ///     an anonymous method (e.g. a lambda) then use
        ///     <see cref="CreateUsingFuncAdaptor{T}(Func{int, T})"/>.
        /// </summary>
        /// <remarks>
        ///     This method exists for performance reasons. Anonymous methods
        ///     always have an associated object created for them, and thus
        ///     using anonymous methods will cause lots of garbage to get created.
        ///     It is preferable to create one instance of an object that captures
        ///     the closure for all of the projection functions that you need and
        ///     create projections from that one instance.
        /// </remarks>
        /// <typeparam name="T">
        ///     The <see cref="Type"/> returned by the delegate.
        /// </typeparam>
        /// <param name="staticGenerator">
        ///     The delegate to convert to a projection.
        /// </param>
        /// <returns>
        ///     A projection representing <paramref name="staticGenerator"/>.
        /// </returns>
        /// <exception cref="System.ArgumentNullException">
        ///     <paramref name="staticGenerator"/> is <c>null</c>.
        /// </exception>
        /// <exception cref="System.InvalidOperationException">
        ///     <paramref name="staticGenerator"/> does not represent
        ///     a publicly accessible method on a publicly accessible class.
        /// </exception>
        public static IProjection<int, T> Create<T>(Func<int, T> staticGenerator)
        {
            return Create<int, T>(staticGenerator);
        }

        /// <summary>
        ///     Creates a projection from the given delegate. The given
        ///     delegate must be a publicly accessible method on a publicly
        ///     accessible class. If you need to create a projection from 
        ///     an anonymous method (e.g. a lambda) then use
        ///     <see cref="CreateUsingFuncAdaptor{T, TResult}(Func{T, TResult})"/>.
        /// </summary>
        /// <remarks>
        ///     This method exists for performance reasons. Anonymous methods
        ///     always have an associated object created for them, and thus
        ///     using anonymous methods will cause lots of garbage to get created.
        ///     It is preferable to create one instance of an object that captures
        ///     the closure for all of the projection functions that you need and
        ///     create projections from that one instance.
        /// </remarks>
        /// <typeparam name="T">
        ///     The <see cref="Type"/> taken as an argument to the delegate.
        /// </typeparam>
        /// <typeparam name="TResult">
        ///     The <see cref="Type"/> returned by the delegate.
        /// </typeparam>
        /// <param name="staticGenerator">
        ///     The delegate to convert to a projection.
        /// </param>
        /// <returns>
        ///     A projection representing <paramref name="staticGenerator"/>.
        /// </returns>
        /// <exception cref="System.ArgumentNullException">
        ///     <paramref name="staticGenerator"/> is <c>null</c>.
        /// </exception>
        /// <exception cref="System.InvalidOperationException">
        ///     <paramref name="staticGenerator"/> does not represent
        ///     a publicly accessible method on a publicly accessible class.
        /// </exception>
        public static IProjection<T, TResult> Create<T, TResult>(Func<T, TResult> staticGenerator)
        {
            Guard.NotNull(staticGenerator, nameof(staticGenerator));

            if (!IsMethodPubliclyAccessible(staticGenerator.Method))
            {
                throw new InvalidOperationException(
$@"This method will only work with public methods.  The method must be accessible by other assemblies.  
That means the containing class must also be public.  If the containing class is nested, it must be public, etc.
Anonymous methods are never public and can not be used with this method.
Alternatives are to either write an {nameof(IProjection<int, T>)} for large data tables, or use {nameof(CreateUsingFuncAdaptor)}
with anonymous methods for small tables.");
            }

            var structGenerator = CodeGenerationContext.CreateStructFunction(staticGenerator);

            return structGenerator;
        }

        /// <summary>
        ///     Creates a projection from the given delegate.
        ///     Please see the remarks on <see cref="Create{T}(Func{int, T})"/>
        ///     for performance considerations.
        /// </summary>
        /// <typeparam name="T">
        ///     The <see cref="Type"/> returned by the delegate.
        /// </typeparam>
        /// <param name="staticGenerator">
        ///     The delegate to convert to a projection.
        /// </param>
        /// <returns>
        ///     A projection representing <paramref name="staticGenerator"/>.
        /// </returns>
        /// <exception cref="System.ArgumentNullException">
        ///     <paramref name="staticGenerator"/> is <c>null</c>.
        /// </exception>
        public static IProjection<int, T> CreateUsingFuncAdaptor<T>(Func<int, T> staticGenerator)
        {
            return CreateUsingFuncAdaptor<int, T>(staticGenerator);
        }

        /// <summary>
        ///     Creates a projection from the given delegate.
        ///     Please see the remarks on <see cref="Create{T,TResult}(Func{T, TResult})"/>
        ///     for performance considerations.
        /// </summary>
        /// <typeparam name="T">
        ///     The <see cref="Type"/> taken as an argument to the delegate.
        /// </typeparam>
        /// <typeparam name="TResult">
        ///     The <see cref="Type"/> returned by the delegate.
        /// </typeparam>
        /// <param name="func">
        ///     The delegate to convert to a projection.
        /// </param>
        /// <returns>
        ///     A projection representing <paramref name="func"/>.
        /// </returns>
        /// <exception cref="System.ArgumentNullException">
        ///     <paramref name="func"/> is <c>null</c>.
        /// </exception>
        public static IProjection<T, TResult> CreateUsingFuncAdaptor<T, TResult>(Func<T, TResult> func)
        {
            Guard.NotNull(func, nameof(func));

            return new FuncProjectionAdapter<T, TResult>(func);
        }

        /// <summary>
        ///     Creates a projection from the given <see cref="IFunc{T, TResult}"/>.
        /// </summary>
        /// <typeparam name="T">
        ///     The <see cref="Type"/> returned by the delegate.
        /// </typeparam>
        /// <param name="staticGenerator">
        ///     The delegate to convert to a projection.
        /// </param>
        /// <returns>
        ///     A projection representing <paramref name="staticGenerator"/>.
        /// </returns>
        /// <exception cref="System.ArgumentNullException">
        ///     <paramref name="staticGenerator"/> is <c>null</c>.
        /// </exception>
        public static IProjection<int, T> Create<T>(IFunc<int, T> staticGenerator)
        {
            return Create<int, T>(staticGenerator);
        }

        /// <summary>
        ///     Creates a projection from the given <see cref="IFunc{T, TResult}"/>.
        /// </summary>
        /// <typeparam name="T">
        ///     The <see cref="Type"/> of the delegate's argument.
        /// </typeparam>
        /// <typeparam name="TResult">
        ///     The <see cref="Type"/> returned by the projection.
        /// </typeparam>
        /// <param name="staticGenerator">
        ///     The delegate to convert to a projection.
        /// </param>
        /// <returns>
        ///     A projection representing <paramref name="staticGenerator"/>.
        /// </returns>
        /// <exception cref="System.ArgumentNullException">
        ///     <paramref name="staticGenerator"/> is <c>null</c>.
        /// </exception>
        public static IProjection<T, TResult> Create<T, TResult>(IFunc<T, TResult> staticGenerator)
        {
            Guard.NotNull(staticGenerator, nameof(staticGenerator));

            var typeArgs = new[]
            {
                typeof(T),
                typeof(TResult),
                staticGenerator.GetType(),
            };

            var constructorArgs = new object[]
            {
                staticGenerator,
            };

            var type = typeof(IFuncProjectionAdapter<,,>).MakeGenericType(typeArgs);
            var instance = Activator.CreateInstance(type, constructorArgs);
            return (IProjection<T, TResult>)instance;
        }

        /// <summary>
        ///     Returns a projection representing the identity operation.
        ///     The created projection simply returns its argument.
        /// </summary>
        /// <typeparam name="T">
        ///     The <see cref="Type"/> being projection.
        /// </typeparam>
        /// <returns>
        ///     A projection equivalent to the identity function.
        /// </returns>
        public static IProjection<T, T> Identity<T>()
        {
            return new IdentityProjection<T>();
        }

        /// <summary>
        ///     Creates a projection representing the operation of indexing
        ///     into the given <see cref="IReadOnlyList{T}"/>.
        /// </summary>
        /// <typeparam name="T">
        ///     The <see cref="Type"/> of data in the <see cref="IReadOnlyList{T}"/>.
        /// </typeparam>
        /// <param name="data">
        ///     The <see cref="IReadOnlyList{T}"/> to be indexed.
        /// </param>
        /// <returns>
        ///     A projection that indexes into <paramref name="data"/>.
        /// </returns>
        /// <exception cref="System.ArgumentNullException">
        ///     <paramref name="data"/> is <c>null</c>.
        /// </exception>
        public static IProjection<int, T> Index<T>(IReadOnlyList<T> data)
        {
            Guard.NotNull(data, nameof(data));

            var typeArgs = new[]
            {
                typeof(T),
                data.GetType(),
            };

            var constructorArgs = new object[]
            {
                data,
            };

            var type = typeof(IndexReadOnlyProjection<,>).MakeGenericType(typeArgs);
            var instance = Activator.CreateInstance(type, constructorArgs);
            return (IProjection<int, T>)instance;
        }

        /// <summary>
        ///     Creates a projection that caches the results of its
        ///     computations. The entire domain of the projection is
        ///     evaluated and cached upon creation. Subsequent
        ///     invocations of the projection will result in their
        ///     cached value.
        /// </summary>
        /// <typeparam name="T">
        ///     The return <see cref="Type"/> of the projection.
        /// </typeparam>
        /// <param name="rowCount">
        ///     Defines the domain of the projection. This is the upper
        ///     bound on the range of integers that can be expected to
        ///     be passed to the projection. This parameter must be
        ///     non-negative.
        /// </param>
        /// <param name="projection">
        ///     The projection whose results are to be cached.
        /// </param>
        /// <returns>
        ///     A new projection that caches the results of 
        ///     <paramref name="projection"/>.
        /// </returns>
        /// <exception cref="System.ArgumentNullException">
        ///     <paramref name="projection"/> is <c>null</c>.
        /// </exception>
        /// <exception cref="System.ArgumentOutOfRangeException">
        ///     <paramref name="rowCount"/> is less than zero (0.)
        /// </exception>
        public static IProjection<int, T> PrepopulatedCache<T>(
            int rowCount,
            IProjection<int, T> projection)
        {
            Guard.GreaterThanOrEqualTo(rowCount, 0, nameof(rowCount));
            Guard.NotNull(projection, nameof(projection));

            var typeArgs = new[]
            {
                typeof(T),
                projection.GetType(),
            };

            var constructorArgs = new object[]
            {
                rowCount,
                projection,
                true
            };

            var type = typeof(CachedGenerator<,>).MakeGenericType(typeArgs);
            var instance = Activator.CreateInstance(type, constructorArgs);
            return (IProjection<int, T>)instance;
        }

        /// <summary>
        ///     Projects the results of one (1) projections using
        ///     a static function.
        ///     <para />
        ///     Let f(x) and g(x) be projections, with
        ///     f: A -> B and g: A -> C
        ///     <para />
        ///     Let h(x, y) be a static method with x e B and y e C,
        ///     so h: (B, C) -> D
        ///     <para />
        ///     Then this method creates p(x), p : A -> D
        ///     such that p(x) = h(f(x), g(x)).
        /// </summary>
        /// <typeparam name="B">
        ///     The <see cref="Type"/> of result returned by the
        ///     first projection.
        /// </typeparam>
        /// <typeparam name="TResult">
        ///     The <see cref="Type"/> of the final projection.
        /// </typeparam>
        /// <param name="projection1">
        ///     The first projection.
        /// </param>
        /// <param name="projector">
        ///     The static method defining how to project the results
        ///     of <paramref name="projection1"/>.
        /// </param>
        /// <returns>
        ///     A projection that projects the results of the given projections.
        /// </returns>
        /// <exception cref="System.ArgumentNullException">
        ///     <paramref name="projection1"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="projector"/> is <c>null</c>.
        /// </exception>
        /// <exception cref="System.InvalidOperationException">
        ///     <paramref name="projector"/> is not static.
        /// </exception>
        public static IProjection<int, TResult> Project<B, TResult>(
            this IProjection<int, B> projection1,
            StaticFunc<B, TResult> projector)
        {
            return Project<int, B, TResult>(projection1, projector);
        }

        /// <summary>
        ///     Projects the results of one (1) projections using
        ///     a static function.
        /// </summary>
        /// <typeparam name="A">
        ///     The initial input <see cref="Type"/>.
        /// </typeparam>
        /// <typeparam name="B">
        ///     The <see cref="Type"/> of result returned by the
        ///     first projection.
        /// </typeparam>
        /// <typeparam name="TResult">
        ///     The <see cref="Type"/> of the final projection.
        /// </typeparam>
        /// <param name="projection1">
        ///     The first projection.
        /// </param>
        /// <param name="projector">
        ///     The static method defining how to project the results
        ///     of <paramref name="projection1"/>.
        /// </param>
        /// <returns>
        ///     A projection that projects the results of the given projections.
        /// </returns>
        /// <exception cref="System.ArgumentNullException">
        ///     <paramref name="projection1"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="projector"/> is <c>null</c>.
        /// </exception>
        /// <exception cref="System.InvalidOperationException">
        ///     <paramref name="projector"/> is not static.
        /// </exception>
        public static IProjection<A, TResult> Project<A, B, TResult>(
            this IProjection<A, B> projection1,
            StaticFunc<B, TResult> projector)
        {
            Guard.NotNull(projection1, nameof(projection1));
            Guard.NotNull(projector, nameof(projector));

            VerifyMethodIsStatic(projector);

            var typeArgs = new[]
            {
                typeof(A),
                typeof(B),
                typeof(TResult),
                projection1.GetType(),
            };

            var constructorArgs = new object[]
            {
                projection1,
                projector,
            };

            var type = typeof(ProjectorGeneratorFunction<,,,>).MakeGenericType(typeArgs);
            var instance = Activator.CreateInstance(type, constructorArgs);
            return (IProjection<A, TResult>)instance;
        }

        /// <summary>
        ///     Projects the results of two (2) projections using
        ///     a static function.
        ///     <para />
        ///     Let f(x) and g(x) be projections, with
        ///     f: A -> B and g: A -> C
        ///     <para />
        ///     Let h(x, y) be a static method with x e B and y e C,
        ///     so h: (B, C) -> D
        ///     <para />
        ///     Then this method creates p(x), p : A -> D
        ///     such that p(x) = h(f(x), g(x)).
        /// </summary>
        /// <typeparam name="B">
        ///     The <see cref="Type"/> of result returned by the
        ///     first projection.
        /// </typeparam>
        /// <typeparam name="C">
        ///     The <see cref="Type"/> of result returned by the
        ///     second projection.
        /// </typeparam>
        /// <typeparam name="TResult">
        ///     The <see cref="Type"/> of the final projection.
        /// </typeparam>
        /// <param name="projection1">
        ///     The first projection.
        /// </param>
        /// <param name="projection2">
        ///     The second projection.
        /// </param>
        /// <param name="projector">
        ///     The static method defining how to project the results
        ///     of <paramref name="projection1"/> and <paramref name="projection2"/>.
        /// </param>
        /// <returns>
        ///     A projection that projects the results of the given projections.
        /// </returns>
        /// <exception cref="System.ArgumentNullException">
        ///     <paramref name="projection1"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="projection2"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="projector"/> is <c>null</c>.
        /// </exception>
        /// <exception cref="System.InvalidOperationException">
        ///     <paramref name="projector"/> is not static.
        /// </exception>
        public static IProjection<int, TResult> Project<B, C, TResult>(
            IProjection<int, B> projection1,
            IProjection<int, C> projection2,
            StaticFunc<B, C, TResult> projector)
        {
            return Project<int, B, C, TResult>(projection1, projection2, projector);
        }

        /// <summary>
        ///     Projects the results of two (2) projections using
        ///     a static function.
        ///     <para />
        ///     Let f(x) and g(x) be projections, with
        ///     f: A -> B and g: A -> C
        ///     <para />
        ///     Let h(x, y) be a static method with x e B and y e C,
        ///     so h: (B, C) -> D
        ///     <para />
        ///     Then this method creates p(x), p : A -> D
        ///     such that p(x) = h(f(x), g(x)).
        /// </summary>
        /// <typeparam name="A">
        ///     The initial input <see cref="Type"/>.
        /// </typeparam>
        /// <typeparam name="B">
        ///     The <see cref="Type"/> of result returned by the
        ///     first projection.
        /// </typeparam>
        /// <typeparam name="C">
        ///     The <see cref="Type"/> of result returned by the
        ///     second projection.
        /// </typeparam>
        /// <typeparam name="TResult">
        ///     The <see cref="Type"/> of the final projection.
        /// </typeparam>
        /// <param name="projection1">
        ///     The first projection.
        /// </param>
        /// <param name="projection2">
        ///     The second projection.
        /// </param>
        /// <param name="projector">
        ///     The static method defining how to project the results
        ///     of <paramref name="projection1"/> and <paramref name="projection2"/>.
        /// </param>
        /// <returns>
        ///     A projection that projects the results of the given projections.
        /// </returns>
        /// <exception cref="System.ArgumentNullException">
        ///     <paramref name="projection1"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="projection2"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="projector"/> is <c>null</c>.
        /// </exception>
        /// <exception cref="System.InvalidOperationException">
        ///     <paramref name="projector"/> is not static.
        /// </exception>
        public static IProjection<A, TResult> Project<A, B, C, TResult>(
            IProjection<A, B> projection1,
            IProjection<A, C> projection2,
            StaticFunc<B, C, TResult> projector)
        {
            Guard.NotNull(projection1, nameof(projection1));
            Guard.NotNull(projection2, nameof(projection2));
            Guard.NotNull(projector, nameof(projector));

            VerifyMethodIsStatic(projector);

            var typeArgs = new[]
            {
                typeof(A),
                typeof(B),
                typeof(C),
                typeof(TResult),
                projection1.GetType(),
                projection2.GetType(),
            };

            var constructorArgs = new object[]
            {
                projection1,
                projection2,
                projector,
            };

            var type = typeof(ProjectorGeneratorFunction<,,,,,>).MakeGenericType(typeArgs);
            var instance = Activator.CreateInstance(type, constructorArgs);
            return (IProjection<A, TResult>)instance;
        }

        /// <summary>
        ///     Projects the results of three (3) projections using
        ///     a static function.
        ///     <para />
        ///     Let f(x), g(x), and h(x) be projections, with
        ///     f: A -> B ; g: A -> C ; h: A -> D
        ///     <para />
        ///     Let k(x, y, z) be a static method with x e B, y e C,
        ///     and z e D so k: (B, C, D) -> E
        ///     <para />
        ///     Then this method creates p(x), p : A -> E
        ///     such that p(x) = k(f(x), g(x), h(x)).
        /// </summary>
        /// <typeparam name="B">
        ///     The <see cref="Type"/> of result returned by the
        ///     first projection.
        /// </typeparam>
        /// <typeparam name="C">
        ///     The <see cref="Type"/> of result returned by the
        ///     second projection.
        /// </typeparam>
        /// <typeparam name="D">
        ///     The <see cref="Type"/> of result returned by the
        ///     third projection.
        /// </typeparam>
        /// <typeparam name="TResult">
        ///     The <see cref="Type"/> of the final projection.
        /// </typeparam>
        /// <param name="projection1">
        ///     The first projection.
        /// </param>
        /// <param name="projection2">
        ///     The second projection.
        /// </param>
        /// <param name="projection3">
        ///     The third projection.
        /// </param>
        /// <param name="projector">
        ///     The static method defining how to project the results
        ///     of <paramref name="projection1"/>, <paramref name="projection2"/>,
        ///     and <paramref name="projection3"/>.
        /// </param>
        /// <returns>
        ///     A projection that projects the results of the given projections.
        /// </returns>
        /// <exception cref="System.ArgumentNullException">
        ///     <paramref name="projection1"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="projection2"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="projection3"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="projector"/> is <c>null</c>.
        /// </exception>
        /// <exception cref="System.InvalidOperationException">
        ///     <paramref name="projector"/> is not static.
        /// </exception>
        public static IProjection<int, TResult> Project<B, C, D, TResult>(
            IProjection<int, B> projection1,
            IProjection<int, C> projection2,
            IProjection<int, D> projection3,
            StaticFunc<B, C, D, TResult> projector)
        {
            return Project<int, B, C, D, TResult>(
                projection1,
                projection2,
                projection3,
                projector);
        }

        /// <summary>
        ///     Projects the results of three (3) projections using
        ///     a static function.
        ///     <para />
        ///     Let f(x), g(x), and h(x) be projections, with
        ///     f: A -> B ; g: A -> C ; h: A -> D
        ///     <para />
        ///     Let k(x, y, z) be a static method with x e B, y e C,
        ///     and z e D so k: (B, C, D) -> E
        ///     <para />
        ///     Then this method creates p(x), p : A -> E
        ///     such that p(x) = k(f(x), g(x), h(x)).
        /// </summary>
        /// <typeparam name="A">
        ///     The initial input <see cref="Type"/>.
        /// </typeparam>
        /// <typeparam name="B">
        ///     The <see cref="Type"/> of result returned by the
        ///     first projection.
        /// </typeparam>
        /// <typeparam name="C">
        ///     The <see cref="Type"/> of result returned by the
        ///     second projection.
        /// </typeparam>
        /// <typeparam name="D">
        ///     The <see cref="Type"/> of result returned by the
        ///     third projection.
        /// </typeparam>
        /// <typeparam name="TResult">
        ///     The <see cref="Type"/> of the final projection.
        /// </typeparam>
        /// <param name="projection1">
        ///     The first projection.
        /// </param>
        /// <param name="projection2">
        ///     The second projection.
        /// </param>
        /// <param name="projection3">
        ///     The third projection.
        /// </param>
        /// <param name="projector">
        ///     The static method defining how to project the results
        ///     of <paramref name="projection1"/>, <paramref name="projection2"/>,
        ///     and <paramref name="projection3"/>.
        /// </param>
        /// <returns>
        ///     A projection that projects the results of the given projections.
        /// </returns>
        /// <exception cref="System.ArgumentNullException">
        ///     <paramref name="projection1"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="projection2"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="projection3"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="projector"/> is <c>null</c>.
        /// </exception>
        /// <exception cref="System.InvalidOperationException">
        ///     <paramref name="projector"/> is not static.
        /// </exception>
        public static IProjection<A, TResult> Project<A, B, C, D, TResult>(
            IProjection<A, B> projection1,
            IProjection<A, C> projection2,
            IProjection<A, D> projection3,
            StaticFunc<B, C, D, TResult> projector)
        {
            Guard.NotNull(projection1, nameof(projection1));
            Guard.NotNull(projection2, nameof(projection2));
            Guard.NotNull(projection3, nameof(projection3));
            Guard.NotNull(projector, nameof(projector));

            VerifyMethodIsStatic(projector);

            var typeArgs = new[]
            {
                typeof(A),
                typeof(B),
                typeof(C),
                typeof(D),
                typeof(TResult),
                projection1.GetType(),
                projection2.GetType(),
                projection3.GetType(),
            };

            var constructorArgs = new object[]
            {
                projection1,
                projection2,
                projection3,
                projector,
            };

            var type = typeof(ProjectorGeneratorFunction<,,,,,,,>).MakeGenericType(typeArgs);
            var instance = Activator.CreateInstance(type, constructorArgs);
            return (IProjection<A, TResult>)instance;
        }

        /// <summary>
        ///     Projects the results of four (4) projections using
        ///     a static function.
        ///     <para />
        ///     Let f(x), g(x), h(x), and k(x) be projections, with
        ///     f: A -> B ; g: A -> C ; h: A -> D ; k : A -> E
        ///     <para />
        ///     Let m(x, y, z, a) be a static method with x e B, y e C,
        ///     z e D, and a e E so k: (B, C, D, E) -> F
        ///     <para />
        ///     Then this method creates p(x), p : A -> F
        ///     such that p(x) = m(f(x), g(x), h(x), k(x)).
        /// </summary>
        /// <typeparam name="B">
        ///     The <see cref="Type"/> of result returned by the
        ///     first projection.
        /// </typeparam>
        /// <typeparam name="C">
        ///     The <see cref="Type"/> of result returned by the
        ///     second projection.
        /// </typeparam>
        /// <typeparam name="D">
        ///     The <see cref="Type"/> of result returned by the
        ///     third projection.
        /// </typeparam>
        /// <typeparam name="E">
        ///     The <see cref="Type"/> of result returned by the
        ///     fourth projection.
        /// </typeparam>
        /// <typeparam name="TResult">
        ///     The <see cref="Type"/> of the final projection.
        /// </typeparam>
        /// <param name="projection1">
        ///     The first projection.
        /// </param>
        /// <param name="projection2">
        ///     The second projection.
        /// </param>
        /// <param name="projection3">
        ///     The third projection.
        /// </param>
        /// <param name="projection4">
        ///     The fourth projection.
        /// </param>
        /// <param name="projector">
        ///     The static method defining how to project the results
        ///     of <paramref name="projection1"/>, <paramref name="projection2"/>,
        ///     <paramref name="projection3"/>, <paramref name="projection4"/>.
        /// </param>
        /// <returns>
        ///     A projection that projects the results of the given projections.
        /// </returns>
        /// <exception cref="System.ArgumentNullException">
        ///     <paramref name="projection1"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="projection2"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="projection3"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="projection4"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="projector"/> is <c>null</c>.
        /// </exception>
        /// <exception cref="System.InvalidOperationException">
        ///     <paramref name="projector"/> is not static.
        /// </exception>
        public static IProjection<int, TResult> Project<B, C, D, E, TResult>(
            IProjection<int, B> projection1,
            IProjection<int, C> projection2,
            IProjection<int, D> projection3,
            IProjection<int, E> projection4,
            StaticFunc<B, C, D, E, TResult> projector)
        {
            return Project<int, B, C, D, E, TResult>(
                projection1,
                projection2,
                projection3,
                projection4,
                projector);
        }

        /// <summary>
        ///     Projects the results of four (4) projections using
        ///     a static function.
        ///     <para />
        ///     Let f(x), g(x), h(x), and k(x) be projections, with
        ///     f: A -> B ; g: A -> C ; h: A -> D ; k : A -> E
        ///     <para />
        ///     Let m(x, y, z, a) be a static method with x e B, y e C,
        ///     z e D, and a e E so k: (B, C, D, E) -> F
        ///     <para />
        ///     Then this method creates p(x), p : A -> F
        ///     such that p(x) = m(f(x), g(x), h(x), k(x)).
        /// </summary>
        /// <typeparam name="A">
        ///     The <see cref="Type"/> of input into the projection.
        /// </typeparam>
        /// <typeparam name="B">
        ///     The <see cref="Type"/> of result returned by the
        ///     first projection.
        /// </typeparam>
        /// <typeparam name="C">
        ///     The <see cref="Type"/> of result returned by the
        ///     second projection.
        /// </typeparam>
        /// <typeparam name="D">
        ///     The <see cref="Type"/> of result returned by the
        ///     third projection.
        /// </typeparam>
        /// <typeparam name="E">
        ///     The <see cref="Type"/> of result returned by the
        ///     fourth projection.
        /// </typeparam>
        /// <typeparam name="TResult">
        ///     The <see cref="Type"/> of the final projection.
        /// </typeparam>
        /// <param name="projection1">
        ///     The first projection.
        /// </param>
        /// <param name="projection2">
        ///     The second projection.
        /// </param>
        /// <param name="projection3">
        ///     The third projection.
        /// </param>
        /// <param name="projection4">
        ///     The fourth projection.
        /// </param>
        /// <param name="projector">
        ///     The static method defining how to project the results
        ///     of <paramref name="projection1"/>, <paramref name="projection2"/>,
        ///     <paramref name="projection3"/>, <paramref name="projection4"/>.
        /// </param>
        /// <returns>
        ///     A projection that projects the results of the given projections.
        /// </returns>
        /// <exception cref="System.ArgumentNullException">
        ///     <paramref name="projection1"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="projection2"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="projection3"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="projection4"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="projector"/> is <c>null</c>.
        /// </exception>
        /// <exception cref="System.InvalidOperationException">
        ///     <paramref name="projector"/> is not static.
        /// </exception>
        public static IProjection<A, TResult> Project<A, B, C, D, E, TResult>(
            IProjection<A, B> projection1,
            IProjection<A, C> projection2,
            IProjection<A, D> projection3,
            IProjection<A, E> projection4,
            StaticFunc<B, C, D, E, TResult> projector)
        {
            Guard.NotNull(projection1, nameof(projection1));
            Guard.NotNull(projection2, nameof(projection2));
            Guard.NotNull(projection3, nameof(projection3));
            Guard.NotNull(projection4, nameof(projection4));
            Guard.NotNull(projector, nameof(projector));

            VerifyMethodIsStatic(projector);

            var typeArgs = new[]
            {
                typeof(A),
                typeof(B),
                typeof(C),
                typeof(D),
                typeof(E),
                typeof(TResult),
                projection1.GetType(),
                projection2.GetType(),
                projection3.GetType(),
                projection4.GetType(),
            };

            var constructorArgs = new object[]
            {
                projection1,
                projection2,
                projection3,
                projection4,
                projector,
            };

            var type = typeof(ProjectorGeneratorFunction<,,,,,,,,,>).MakeGenericType(typeArgs);
            var instance = Activator.CreateInstance(type, constructorArgs);
            return (IProjection<A, TResult>)instance;
        }

        /// <summary>
        ///     Selects the results of one (1) projection along with
        ///     the initial integer argument using the given combination
        ///     function.
        ///     <para />
        ///     Let f(x) be a projection, with f: A -> B
        ///     <para />
        ///     Let g(i, x) be a function with i e A, x e B, so g: (A, B) -> C
        ///     <para />
        ///     Then this method creates p(x), p : A -> C
        ///     such that p(x) = g(x, f(x)).
        /// </summary>
        /// <remarks>
        ///     Use the Select methods when your function needs access to
        ///     the original integer argument; use Project otherwise.
        /// </remarks>
        /// <typeparam name="B">
        ///     The <see cref="Type"/> of result returned by the
        ///     first projection.
        /// </typeparam>
        /// <typeparam name="TResult">
        ///     The <see cref="Type"/> of the final projection.
        /// </typeparam>
        /// <param name="projection1">
        ///     The first projection.
        /// </param>
        /// <param name="selector">
        ///     The method defining how to project the results
        ///     of <paramref name="projection1"/>.
        /// </param>
        /// <returns>
        ///     A projection that projects the results of the given projections.
        /// </returns>
        /// <exception cref="System.ArgumentNullException">
        ///     <paramref name="projection1"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="selector"/> is <c>null</c>.
        /// </exception>
        public static IProjection<int, TResult> Select<B, TResult>(
            IProjection<int, B> projection1,
            Func<int, B, TResult> selector)
        {
            Guard.NotNull(selector, nameof(selector));

            var funcWrapper = new FuncInterfaceAdaptor<int, B, TResult>(selector);
            return Select(projection1, funcWrapper);
        }

        /// <summary>
        ///     Selects the results of one (1) projection along with
        ///     the initial integer argument using the given combination
        ///     function.
        ///     <para />
        ///     Let f(x) be a projection, with f: A -> B
        ///     <para />
        ///     Let g(i, x) be a function with i e A, x e B, so g: (A, B) -> C
        ///     <para />
        ///     Then this method creates p(x), p : A -> C
        ///     such that p(x) = g(x, f(x)).
        /// </summary>
        /// <remarks>
        ///     Use the Select methods when your function needs access to
        ///     the original integer argument; use Project otherwise.
        /// </remarks>
        /// <typeparam name="B">
        ///     The <see cref="Type"/> of result returned by the
        ///     first projection.
        /// </typeparam>
        /// <typeparam name="TResult">
        ///     The <see cref="Type"/> of the final projection.
        /// </typeparam>
        /// <param name="projection1">
        ///     The first projection.
        /// </param>
        /// <param name="selector">
        ///     The method defining how to project the results
        ///     of <paramref name="projection1"/>.
        /// </param>
        /// <returns>
        ///     A projection that projects the results of the given projections.
        /// </returns>
        /// <exception cref="System.ArgumentNullException">
        ///     <paramref name="projection1"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="selector"/> is <c>null</c>.
        /// </exception>
        public static IProjection<int, TResult> Select<B, TResult>(
            IProjection<int, B> projection1,
            IFunc<int, B, TResult> selector)
        {
            return Select<int, B, TResult>(projection1, selector);
        }

        /// <summary>
        ///     Selects the results of one (1) projection along with
        ///     the initial integer argument using the given combination
        ///     function.
        ///     <para />
        ///     Let f(x) be a projection, with f: A -> B
        ///     <para />
        ///     Let g(i, x) be a function with i e A, x e B, so g: (A, B) -> C
        ///     <para />
        ///     Then this method creates p(x), p : A -> C
        ///     such that p(x) = g(x, f(x)).
        /// </summary>
        /// <remarks>
        ///     Use the Select methods when your function needs access to
        ///     the original integer argument; use Project otherwise.
        /// </remarks>
        /// <typeparam name="A">
        ///     The <see cref="Type"/> of input.
        /// </typeparam>
        /// <typeparam name="B">
        ///     The <see cref="Type"/> of result returned by the
        ///     first projection.
        /// </typeparam>
        /// <typeparam name="TResult">
        ///     The <see cref="Type"/> of the final projection.
        /// </typeparam>
        /// <param name="projection1">
        ///     The first projection.
        /// </param>
        /// <param name="selector">
        ///     The method defining how to project the results
        ///     of <paramref name="projection1"/>.
        /// </param>
        /// <returns>
        ///     A projection that projects the results of the given projections.
        /// </returns>
        /// <exception cref="System.ArgumentNullException">
        ///     <paramref name="projection1"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="selector"/> is <c>null</c>.
        /// </exception>
        public static IProjection<A, TResult> Select<A, B, TResult>(
            IProjection<A, B> projection1,
            IFunc<A, B, TResult> selector)
        {
            Guard.NotNull(projection1, nameof(projection1));
            Guard.NotNull(selector, nameof(selector));

            var typeArguments = new[]
            {
                typeof(TResult),
                projection1.GetType(),
                typeof(A),
                typeof(B),
                selector.GetType(),
            };

            var constructorArguments = new object[]
            {
                projection1,
                selector,
            };

            var type = typeof(SelectGenerator<,,,,>).MakeGenericType(typeArguments);
            var instance = Activator.CreateInstance(type, constructorArguments);
            return (IProjection<A, TResult>)instance;
        }

        /// <summary>
        ///     Selects the results of two (2) projections along with
        ///     the initial integer argument using the given combination
        ///     function.
        ///     <para />
        ///     Let f(x) and g(x) be projections, with
        ///     f: A -> B ; g: A -> C
        ///     <para />
        ///     Let m(i, x, y) be a function with i e A, x e B, y e C,
        ///     and so m: (A, B, C) -> E
        ///     <para />
        ///     Then this method creates p(x), p : A -> E
        ///     such that p(x) = m(x, f(x), g(x)).
        /// </summary>
        /// <remarks>
        ///     Use the Select methods when your function needs access to
        ///     the original integer argument; use Project otherwise.
        /// </remarks>
        /// <typeparam name="B">
        ///     The <see cref="Type"/> of result returned by the
        ///     first projection.
        /// </typeparam>
        /// <typeparam name="C">
        ///     The <see cref="Type"/> of result returned by the
        ///     second projection.
        /// </typeparam>
        /// <typeparam name="TResult">
        ///     The <see cref="Type"/> of the final projection.
        /// </typeparam>
        /// <param name="projection1">
        ///     The first projection.
        /// </param>
        /// <param name="projection2">
        ///     The second projection.
        /// </param>
        /// <param name="selector">
        ///     The method defining how to project the results
        ///     of <paramref name="projection1"/> and <paramref name="projection2"/>.
        /// </param>
        /// <returns>
        ///     A projection that projects the results of the given projections.
        /// </returns>
        /// <exception cref="System.ArgumentNullException">
        ///     <paramref name="projection1"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="projection2"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="selector"/> is <c>null</c>.
        /// </exception>
        public static IProjection<int, TResult> Select<B, C, TResult>(
            IProjection<int, B> projection1,
            IProjection<int, C> projection2,
            Func<int, B, C, TResult> selector)
        {
            Guard.NotNull(selector, nameof(selector));

            var funcWrapper = new FuncInterfaceAdaptor<int, B, C, TResult>(selector);
            return Select(projection1, projection2, funcWrapper);
        }

        /// <summary>
        ///     Selects the results of two (2) projections along with
        ///     the initial integer argument using the given combination
        ///     function.
        ///     <para />
        ///     Let f(x) and g(x) be projections, with
        ///     f: A -> B ; g: A -> C
        ///     <para />
        ///     Let m(i, x, y) be a function with i e A, x e B, y e C,
        ///     and so m: (A, B, C) -> E
        ///     <para />
        ///     Then this method creates p(x), p : A -> E
        ///     such that p(x) = m(x, f(x), g(x)).
        /// </summary>
        /// <remarks>
        ///     Use the Select methods when your function needs access to
        ///     the original integer argument; use Project otherwise.
        /// </remarks>
        /// <typeparam name="B">
        ///     The <see cref="Type"/> of result returned by the
        ///     first projection.
        /// </typeparam>
        /// <typeparam name="C">
        ///     The <see cref="Type"/> of result returned by the
        ///     second projection.
        /// </typeparam>
        /// <typeparam name="TResult">
        ///     The <see cref="Type"/> of the final projection.
        /// </typeparam>
        /// <param name="projection1">
        ///     The first projection.
        /// </param>
        /// <param name="projection2">
        ///     The second projection.
        /// </param>
        /// <param name="selector">
        ///     The method defining how to project the results
        ///     of <paramref name="projection1"/> and <paramref name="projection2"/>.
        /// </param>
        /// <returns>
        ///     A projection that projects the results of the given projections.
        /// </returns>
        /// <exception cref="System.ArgumentNullException">
        ///     <paramref name="projection1"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="projection2"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="selector"/> is <c>null</c>.
        /// </exception>
        public static IProjection<int, TResult> Select<B, C, TResult>(
            IProjection<int, B> projection1,
            IProjection<int, C> projection2,
            IFunc<int, B, C, TResult> selector)
        {
            return Select<int, B, C, TResult>(projection1, projection2, selector);
        }

        /// <summary>
        ///     Selects the results of two (2) projections along with
        ///     the initial integer argument using the given combination
        ///     function.
        ///     <para />
        ///     Let f(x) and g(x) be projections, with
        ///     f: A -> B ; g: A -> C
        ///     <para />
        ///     Let m(i, x, y) be a function with i e A, x e B, y e C,
        ///     and so m: (A, B, C) -> E
        ///     <para />
        ///     Then this method creates p(x), p : A -> E
        ///     such that p(x) = m(x, f(x), g(x)).
        /// </summary>
        /// <remarks>
        ///     Use the Select methods when your function needs access to
        ///     the original integer argument; use Project otherwise.
        /// </remarks>
        /// <typeparam name="A">
        ///     The <see cref="Type"/> of input.
        /// </typeparam>
        /// <typeparam name="B">
        ///     The <see cref="Type"/> of result returned by the
        ///     first projection.
        /// </typeparam>
        /// <typeparam name="C">
        ///     The <see cref="Type"/> of result returned by the
        ///     second projection.
        /// </typeparam>
        /// <typeparam name="TResult">
        ///     The <see cref="Type"/> of the final projection.
        /// </typeparam>
        /// <param name="projection1">
        ///     The first projection.
        /// </param>
        /// <param name="projection2">
        ///     The second projection.
        /// </param>
        /// <param name="selector">
        ///     The method defining how to project the results
        ///     of <paramref name="projection1"/> and <paramref name="projection2"/>.
        /// </param>
        /// <returns>
        ///     A projection that projects the results of the given projections.
        /// </returns>
        /// <exception cref="System.ArgumentNullException">
        ///     <paramref name="projection1"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="projection2"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="selector"/> is <c>null</c>.
        /// </exception>
        public static IProjection<A, TResult> Select<A, B, C, TResult>(
            IProjection<A, B> projection1,
            IProjection<A, C> projection2,
            IFunc<A, B, C, TResult> selector)
        {
            Guard.NotNull(projection1, nameof(projection1));
            Guard.NotNull(projection2, nameof(projection2));
            Guard.NotNull(selector, nameof(selector));

            var typeArguments = new[]
            {
                typeof(TResult),
                projection1.GetType(),
                projection2.GetType(),
                typeof(A),
                typeof(B),
                typeof(C),
                selector.GetType(),
            };

            var constructorArguments = new object[]
            {
                projection1,
                projection2,
                selector,
            };

            var type = typeof(SelectGenerator<,,,,,,>).MakeGenericType(typeArguments);
            var instance = Activator.CreateInstance(type, constructorArguments);
            return (IProjection<A, TResult>)instance;
        }

        /// <summary>
        ///     Selects the results of three (3) projections along with
        ///     the initial integer argument using the given combination
        ///     function.
        ///     <para />
        ///     Let f(x), g(x), and h(x) be projections, with
        ///     f: A -> B ; g: A -> C ; h: A -> D
        ///     <para />
        ///     Let m(i, x, y, z) be a function with i e A, x e B, y e C,
        ///     z e D, and so m: (A, B, C, D) -> F
        ///     <para />
        ///     Then this method creates p(x), p : A -> F
        ///     such that p(x) = m(x, f(x), g(x), h(x)).
        /// </summary>
        /// <remarks>
        ///     Use the Select methods when your function needs access to
        ///     the original integer argument; use Project otherwise.
        /// </remarks>
        /// <typeparam name="B">
        ///     The <see cref="Type"/> of result returned by the
        ///     first projection.
        /// </typeparam>
        /// <typeparam name="C">
        ///     The <see cref="Type"/> of result returned by the
        ///     second projection.
        /// </typeparam>
        /// <typeparam name="D">
        ///     The <see cref="Type"/> of result returned by the
        ///     third projection.
        /// </typeparam>
        /// <typeparam name="TResult">
        ///     The <see cref="Type"/> of the final projection.
        /// </typeparam>
        /// <param name="projection1">
        ///     The first projection.
        /// </param>
        /// <param name="projection2">
        ///     The second projection.
        /// </param>
        /// <param name="projection3">
        ///     The third projection.
        /// </param>
        /// <param name="selector">
        ///     The method defining how to project the results
        ///     of <paramref name="projection1"/>, <paramref name="projection2"/>,
        ///     and <paramref name="projection3"/>.
        /// </param>
        /// <returns>
        ///     A projection that projects the results of the given projections.
        /// </returns>
        /// <exception cref="System.ArgumentNullException">
        ///     <paramref name="projection1"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="projection2"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="projection3"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="selector"/> is <c>null</c>.
        /// </exception>
        public static IProjection<int, TResult> Select<B, C, D, TResult>(
            IProjection<int, B> projection1,
            IProjection<int, C> projection2,
            IProjection<int, D> projection3,
            Func<int, B, C, TResult> selector)
        {
            Guard.NotNull(selector, nameof(selector));

            var funcWrapper = new FuncInterfaceAdaptor<int, B, C, TResult>(selector);
            return Select(projection1, projection2, funcWrapper);
        }

        /// <summary>
        ///     Selects the results of three (3) projections along with
        ///     the initial integer argument using the given combination
        ///     function.
        ///     <para />
        ///     Let f(x), g(x), h(x), be projections, with
        ///     f: A -> B ; g: A -> C ; h: A -> D ; k : A -> E
        ///     <para />
        ///     Let m(i, x, y, z) be a function with i e A, x e B, y e C,
        ///     z e D, and so m: (A, B, C, D) -> F
        ///     <para />
        ///     Then this method creates p(x), p : A -> F
        ///     such that p(x) = m(x, f(x), g(x), h(x)).
        /// </summary>
        /// <remarks>
        ///     Use the Select methods when your function needs access to
        ///     the original integer argument; use Project otherwise.
        /// </remarks>
        /// <typeparam name="B">
        ///     The <see cref="Type"/> of result returned by the
        ///     first projection.
        /// </typeparam>
        /// <typeparam name="C">
        ///     The <see cref="Type"/> of result returned by the
        ///     second projection.
        /// </typeparam>
        /// <typeparam name="D">
        ///     The <see cref="Type"/> of result returned by the
        ///     third projection.
        /// </typeparam>
        /// <typeparam name="TResult">
        ///     The <see cref="Type"/> of the final projection.
        /// </typeparam>
        /// <param name="projection1">
        ///     The first projection.
        /// </param>
        /// <param name="projection2">
        ///     The second projection.
        /// </param>
        /// <param name="projection3">
        ///     The third projection.
        /// </param>
        /// <param name="selector">
        ///     The method defining how to project the results
        ///     of <paramref name="projection1"/>, <paramref name="projection2"/>,
        ///     and <paramref name="projection3"/>.
        /// </param>
        /// <returns>
        ///     A projection that projects the results of the given projections.
        /// </returns>
        /// <exception cref="System.ArgumentNullException">
        ///     <paramref name="projection1"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="projection2"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="projection3"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="selector"/> is <c>null</c>.
        /// </exception>
        public static IProjection<int, TResult> Select<B, C, D, TResult>(
            IProjection<int, B> projection1,
            IProjection<int, C> projection2,
            IProjection<int, D> projection3,
            IFunc<int, B, C, D, TResult> selector)
        {
            return Select<int, B, C, D, TResult>(projection1, projection2, projection3, selector);
        }

        /// <summary>
        ///     Selects the results of three (3) projections along with
        ///     the initial integer argument using the given combination
        ///     function.
        ///     <para />
        ///     Let f(x), g(x), h(x), be projections, with
        ///     f: A -> B ; g: A -> C ; h: A -> D ; k : A -> E
        ///     <para />
        ///     Let m(i, x, y, z) be a function with i e A, x e B, y e C,
        ///     z e D, and so m: (A, B, C, D) -> F
        ///     <para />
        ///     Then this method creates p(x), p : A -> F
        ///     such that p(x) = m(x, f(x), g(x), h(x)).
        /// </summary>
        /// <remarks>
        ///     Use the Select methods when your function needs access to
        ///     the original integer argument; use Project otherwise.
        /// </remarks>
        /// <typeparam name="A">
        ///     The <see cref="Type"/> of input.
        /// </typeparam>
        /// <typeparam name="B">
        ///     The <see cref="Type"/> of result returned by the
        ///     first projection.
        /// </typeparam>
        /// <typeparam name="C">
        ///     The <see cref="Type"/> of result returned by the
        ///     second projection.
        /// </typeparam>
        /// <typeparam name="D">
        ///     The <see cref="Type"/> of result returned by the
        ///     third projection.
        /// </typeparam>
        /// <typeparam name="TResult">
        ///     The <see cref="Type"/> of the final projection.
        /// </typeparam>
        /// <param name="projection1">
        ///     The first projection.
        /// </param>
        /// <param name="projection2">
        ///     The second projection.
        /// </param>
        /// <param name="projection3">
        ///     The third projection.
        /// </param>
        /// <param name="selector">
        ///     The method defining how to project the results
        ///     of <paramref name="projection1"/>, <paramref name="projection2"/>,
        ///     and <paramref name="projection3"/>.
        /// </param>
        /// <returns>
        ///     A projection that projects the results of the given projections.
        /// </returns>
        /// <exception cref="System.ArgumentNullException">
        ///     <paramref name="projection1"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="projection2"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="projection3"/> is <c>null</c>.
        ///     - or -
        ///     <paramref name="selector"/> is <c>null</c>.
        /// </exception>
        public static IProjection<A, TResult> Select<A, B, C, D, TResult>(
            IProjection<A, B> projection1,
            IProjection<A, C> projection2,
            IProjection<A, D> projection3,
            IFunc<A, B, C, D, TResult> selector)
        {
            Guard.NotNull(projection1, nameof(projection1));
            Guard.NotNull(projection2, nameof(projection2));
            Guard.NotNull(projection3, nameof(projection3));
            Guard.NotNull(selector, nameof(selector));

            var typeArguments = new[]
            {
                typeof(TResult),
                projection1.GetType(),
                projection2.GetType(),
                projection3.GetType(),
                typeof(A),
                typeof(B),
                typeof(C),
                typeof(D),
                selector.GetType(),
            };

            var constructorArguments = new object[]
            {
                projection1,
                projection2,
                projection3,
                selector,
            };

            var type = typeof(SelectGenerator<,,,,,,,,>).MakeGenericType(typeArguments);
            var instance = Activator.CreateInstance(type, constructorArguments);
            return (IProjection<A, TResult>)instance;
        }

        private static bool IsMethodPubliclyAccessible(MethodInfo methodInfo)
        {
            Debug.Assert(methodInfo != null);

            if (!methodInfo.IsPublic)
            {
                return false;
            }

            Type containingClass = methodInfo.DeclaringType;
            while (true)
            {
                Debug.Assert(containingClass != null);
                if (!containingClass.IsPublic && !containingClass.IsNestedPublic)
                {
                    return false;
                }

                if (!containingClass.IsNested)
                {
                    break;
                }

                containingClass = containingClass.DeclaringType;
            }

            return true;
        }

        private static void VerifyMethodIsStatic(Delegate @delegate)
        {
            if (@delegate.Target != null)
            {
                throw new InvalidOperationException(
                    "Projector functions must be static. Provide state through a generator argument.");
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        private struct AggregateRowsInViewportColumnGenerator<T, TAggregate, TGenerator>
            : IProjection<int, TAggregate>,
              IViewportSensitiveProjection
              where TGenerator : IProjection<int, T>
        {
            private readonly TGenerator columnToAggregate;
            private readonly VisibleTableRegionContainer viewport;

            public AggregateRowsInViewportColumnGenerator(TGenerator columnToAggregate)
            {
                this.columnToAggregate = columnToAggregate;
                this.viewport = new VisibleTableRegionContainer();
            }

            public TAggregate this[int value]
            {
                get
                {
                    return this.viewport.VisibleTableRegion.AggregateRowsInViewport<T, TAggregate>(
                        this.columnToAggregate,
                        AggregationMode.Sum);
                }
            }

            public Type SourceType => typeof(int);

            public Type ResultType => typeof(TAggregate);

            public bool DependsOnViewport => true;

            public object Clone()
            {
                return new AggregateRowsInViewportColumnGenerator<T, TAggregate, TGenerator>(
                    ViewportSensitiveProjection.CloneIfViewportSensitive(this.columnToAggregate));
            }

            public bool NotifyViewportChanged(IVisibleTableRegion viewport)
            {
                this.viewport.VisibleTableRegion = viewport;
                ViewportSensitiveProjection.NotifyViewportChanged(this.columnToAggregate, viewport);
                return true;
            }
        }

        private struct CachedGenerator<T, TGenerator>
            : IProjection<int, T>,
              IViewportSensitiveProjection
              where TGenerator : IProjection<int, T>
        {
            private readonly T[] cache;
            private TGenerator generator;

            public CachedGenerator(int rowCount, TGenerator generator)
                : this(rowCount, generator, true)
            {
            }

            public CachedGenerator(int rowCount, TGenerator generator, bool dataReady)
            {
                this.cache = new T[rowCount];
                this.generator = generator;

                if (dataReady)
                {
                    this.ResetCache();
                }
            }

            private void ResetCache()
            {
                for (int i = 0; i < this.cache.Length; ++i)
                {
                    this.cache[i] = this.generator[i];
                }
            }

            public T this[int value]
            {
                get
                {
                    return this.cache[value];
                }
            }

            public Type SourceType
            {
                get
                {
                    return typeof(int);
                }
            }

            public Type ResultType
            {
                get
                {
                    return typeof(T);
                }
            }

            public object Clone()
            {
                if (this.DependsOnViewport)
                {
                    return new CachedGenerator<T, TGenerator>(
                        this.cache.Length,
                        this.generator.CloneIfViewportSensitive(),
                        false);  // data not ready until the viewport is set.
                }
                else
                {
                    return this;
                }
            }

            public bool NotifyViewportChanged(IVisibleTableRegion newViewport)
            {
                if (this.generator.NotifyViewportChanged(newViewport))
                {
                    this.ResetCache();
                    return true;
                }

                return false;
            }

            public bool DependsOnViewport => this.generator.DependsOnViewport();
        }

        private struct CachedOnFirstUseColumnGenerator<T, TGenerator>
            : IProjection<int, T>,
              IViewportSensitiveProjection
              where TGenerator : IProjection<int, T>
        {
            const byte byteTrue = 1;
            const byte byteFalse = 0;

            private readonly T[] cache;
            private readonly byte[] isCached;
            private TGenerator generator;

            public CachedOnFirstUseColumnGenerator(int rowCount, TGenerator generator)
            {
                this.cache = new T[rowCount];
                this.isCached = new byte[rowCount];
                this.generator = generator;
            }

            private void ResetCache()
            {
                for (int i = 0; i < this.cache.Length; ++i)
                {
                    this.isCached[i] = byteFalse;
                }
            }

            public T this[int value]
            {
                get
                {
                    if (this.isCached[value] != byteTrue)
                    {
                        this.cache[value] = this.generator[value];
                        this.isCached[value] = byteTrue;
                    }

                    return this.cache[value];
                }
            }

            public Type SourceType
            {
                get
                {
                    return typeof(int);
                }
            }

            public Type ResultType
            {
                get
                {
                    return typeof(T);
                }
            }

            public object Clone()
            {
                if (this.DependsOnViewport)
                {
                    return new CachedOnFirstUseColumnGenerator<T, TGenerator>(
                        this.cache.Length,
                        this.generator.CloneIfViewportSensitive());
                }
                else
                {
                    return this;
                }
            }

            public bool NotifyViewportChanged(IVisibleTableRegion newViewport)
            {
                if (this.generator.NotifyViewportChanged(newViewport))
                {
                    this.ResetCache();
                    return true;
                }

                return false;
            }

            public bool DependsOnViewport => this.generator.DependsOnViewport();
        }

        private static class CacheViewportColumn
        {
            public static IProjection<TArg, TResult> Create<TArg, TResult>(IProjection<TArg, TResult> projection)
            {
                var typeArgs = new[]
                {
                    typeof(TResult),
                    projection.GetType(),
                };

                var constructorArgs = new[]
                {
                    projection,
                };

                var type = typeof(CacheViewportColumnGenerator<,>).MakeGenericType(typeArgs);
                var instance = Activator.CreateInstance(type, constructorArgs);
                return (IProjection<TArg, TResult>)instance;
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        private struct CacheViewportColumnGenerator<T, TGenerator>
            : IProjection<int, T>,
              IViewportSensitiveProjection
              where TGenerator : IProjection<int, T>
        {
            private TGenerator generator;
            private readonly ResultCache resultCache;

            public CacheViewportColumnGenerator(TGenerator generator)
            {
                this.generator = generator;
                this.resultCache = new ResultCache();
            }

            // IProjection<int, TAggregate>
            public T this[int value]
            {
                get
                {
                    if (!this.resultCache.IsValid)
                    {
                        // tried used Lazy<T> here, but then the Lazy would hold on to a copy of the generator
                        // which is often a struct.  Updates to the struct would not be reflected in the copy
                        // being held onto by the lazy.
                        lock (this.resultCache)
                        {
                            if (!this.resultCache.IsValid)
                            {
                                this.resultCache.Result = this.generator[value];
                            }
                        }
                    }

                    return this.resultCache.Result;
                }
            }

            public Type SourceType => typeof(int);

            public Type ResultType => typeof(T);

            // IViewportSensitiveProjection
            public object Clone()
            {
                if (ViewportSensitiveProjection.DependsOnViewport(this.generator))
                {
                    return new CacheViewportColumnGenerator<T, TGenerator>(
                        ViewportSensitiveProjection.CloneIfViewportSensitive(this.generator));
                }
                else
                {
                    return this;
                }
            }


            public bool NotifyViewportChanged(IVisibleTableRegion viewport)
            {
                if (ViewportSensitiveProjection.NotifyViewportChanged(this.generator, viewport))
                {
                    this.resultCache.Invalidate();
                    return true;
                }

                return false;
            }

            public bool DependsOnViewport => ViewportSensitiveProjection.DependsOnViewport(this.generator);

            private sealed class ResultCache
            {
                private T result;

                public T Result
                {
                    get => this.result;

                    set
                    {
                        this.result = value;
                        this.IsValid = true;
                    }
                }

                public bool IsValid { get; private set; }

                public void Invalidate()
                {
                    this.IsValid = false;
                }
            }
        }

        private struct CompositionProjection<T1, T2, TResult, TProjection1, TProjection2>
            : IProjection<T1, TResult>
              where TProjection1 : IProjection<T1, T2>
              where TProjection2 : IProjection<T2, TResult>
        {
            private readonly TProjection1 source;
            private readonly TProjection2 projection;

            public CompositionProjection(
                TProjection1 source,
                TProjection2 projection)
            {
                Debug.Assert(source != null);
                Debug.Assert(projection != null);

                this.source = source;
                this.projection = projection;
            }

            public TResult this[T1 value] => this.projection[this.source[value]];

            public Type SourceType => typeof(T1);

            public Type ResultType => typeof(TResult);
        }

        private struct ConstantProjection<T, TResult>
            : IProjection<T, TResult>
        {
            private readonly TResult constant;

            public ConstantProjection(TResult constant)
            {
                this.constant = constant;
            }

            public TResult this[T value]
            {
                get { return this.constant; }
            }

            public Type SourceType
            {
                get { return typeof(int); }
            }

            public Type ResultType
            {
                get { return typeof(T); }
            }
        }

        private struct FuncProjectionAdapter<T, TResult>
            : IProjection<T, TResult>
        {
            private readonly Func<T, TResult> func;

            public FuncProjectionAdapter(Func<T, TResult> func)
            {
                Debug.Assert(func != null);

                this.func = func;
            }

            public TResult this[T value]
            {
                get
                {
                    return this.func(value);
                }
            }

            public Type SourceType
            {
                get
                {
                    return typeof(T);
                }
            }

            public Type ResultType
            {
                get
                {
                    return typeof(TResult);
                }
            }
        }

        private struct FuncInterfaceAdaptor<T1, TResult>
            : IFunc<T1, TResult>
        {
            private readonly Func<T1, TResult> func;

            public FuncInterfaceAdaptor(Func<T1, TResult> func)
            {
                this.func = func;
            }

            public TResult Invoke(T1 t1)
            {
                return this.func.Invoke(t1);
            }
        }

        private struct FuncInterfaceAdaptor<T1, T2, TResult>
            : IFunc<T1, T2, TResult>
        {
            private readonly Func<T1, T2, TResult> func;

            public FuncInterfaceAdaptor(Func<T1, T2, TResult> func)
            {
                this.func = func;
            }

            public TResult Invoke(T1 t1, T2 t2)
            {
                return this.func.Invoke(t1, t2);
            }
        }

        private struct FuncInterfaceAdaptor<T1, T2, T3, TResult>
            : IFunc<T1, T2, T3, TResult>
        {
            private readonly Func<T1, T2, T3, TResult> func;

            public FuncInterfaceAdaptor(Func<T1, T2, T3, TResult> func)
            {
                this.func = func;
            }

            public TResult Invoke(T1 t1, T2 t2, T3 t3)
            {
                return this.func.Invoke(t1, t2, t3);
            }
        }

        private struct IFuncProjectionAdapter<T, TResult, TFunc>
            : IProjection<T, TResult>
              where TFunc : IFunc<T, TResult>
        {
            private readonly TFunc func;

            public IFuncProjectionAdapter(TFunc func)
            {
                Debug.Assert(func != null);

                this.func = func;
            }

            public TResult this[T value]
            {
                get
                {
                    return this.func.Invoke(value);
                }
            }

            public Type SourceType
            {
                get
                {
                    return typeof(T);
                }
            }

            public Type ResultType
            {
                get
                {
                    return typeof(TResult);
                }
            }
        }

        private struct IdentityProjection<T>
            : IProjection<T, T>
        {
            public T this[T value] => value;

            public Type SourceType => typeof(T);

            public Type ResultType => typeof(T);
        }

        private struct IndexReadOnlyProjection<T, TReadOnlyList>
            : IProjection<int, T>
              where TReadOnlyList : IReadOnlyList<T>
        {
            //
            // Unfortunately, IList<T> and IReadOnlyList<T> do not
            // share a common base that has an indexer, so we are specializing
            // our index projections to avoid switching on types in the actual
            // index operation.
            //
            private readonly TReadOnlyList data;

            public IndexReadOnlyProjection(TReadOnlyList data)
            {
                this.data = data;
            }

            public Type SourceType => typeof(int);

            public Type ResultType => typeof(T);

            public T this[int value] => this.data[value];
        }

        private struct ProjectorGeneratorFunction<T1, T2, TResult, TProjection1>
            : IProjection<T1, TResult>,
              IViewportSensitiveProjection
              where TProjection1 : IProjection<T1, T2>
        {
            private readonly TProjection1 projection1;
            private readonly StaticFunc<T2, TResult> projector;

            public ProjectorGeneratorFunction(
                TProjection1 projection1,
                StaticFunc<T2, TResult> projector)
            {
                this.projection1 = projection1;
                this.projector = projector;
            }

            public TResult this[T1 value]
            {
                get
                {
                    return projector.Invoke(this.projection1[value]);
                }
            }

            public Type SourceType
            {
                get { return typeof(T1); }
            }

            public Type ResultType
            {
                get { return typeof(TResult); }
            }

            public object Clone()
            {
                if (this.DependsOnViewport)
                {
                    return new ProjectorGeneratorFunction<T1, T2, TResult, TProjection1>(
                        this.projection1.CloneIfViewportSensitive(),
                        projector);
                }
                else
                {
                    return this;
                }
            }

            public bool NotifyViewportChanged(IVisibleTableRegion newViewport)
            {
                bool result = false;
                result |= this.projection1.NotifyViewportChanged(newViewport);
                return result;
            }

            public bool DependsOnViewport => this.projection1.DependsOnViewport();
        }

        private struct ProjectorGeneratorFunction<T1, T2, T3, TResult, TProjection1, TProjection2>
            : IProjection<T1, TResult>,
              IViewportSensitiveProjection
              where TProjection1 : IProjection<T1, T2>
              where TProjection2 : IProjection<T1, T3>
        {
            private readonly TProjection1 projection1;
            private readonly TProjection2 projection2;
            private readonly StaticFunc<T2, T3, TResult> projector;

            public ProjectorGeneratorFunction(
                TProjection1 projection1,
                TProjection2 projection2,
                StaticFunc<T2, T3, TResult> projector)
            {
                this.projection1 = projection1;
                this.projection2 = projection2;
                this.projector = projector;
            }

            public TResult this[T1 value]
            {
                get
                {
                    return projector.Invoke(
                        projection1[value],
                        projection2[value]);
                }
            }

            public Type SourceType
            {
                get { return typeof(T1); }
            }

            public Type ResultType
            {
                get { return typeof(TResult); }
            }

            public object Clone()
            {
                if (this.DependsOnViewport)
                {
                    return new ProjectorGeneratorFunction<T1, T2, T3, TResult, TProjection1, TProjection2>(
                        this.projection1.CloneIfViewportSensitive(),
                        this.projection2.CloneIfViewportSensitive(),
                        projector);
                }
                else
                {
                    return this;
                }
            }

            public bool NotifyViewportChanged(IVisibleTableRegion newViewport)
            {
                bool result = false;
                result |= this.projection1.NotifyViewportChanged(newViewport);
                result |= this.projection2.NotifyViewportChanged(newViewport);
                return result;
            }

            public bool DependsOnViewport =>
                this.projection1.DependsOnViewport() ||
                this.projection2.DependsOnViewport();
        }

        private struct ProjectorGeneratorFunction<T1, T2, T3, T4, TResult, TProjection1, TProjection2, TProjection3>
            : IProjection<T1, TResult>,
              IViewportSensitiveProjection
              where TProjection1 : IProjection<T1, T2>
              where TProjection2 : IProjection<T1, T3>
              where TProjection3 : IProjection<T1, T4>
        {
            private readonly TProjection1 projection1;
            private readonly TProjection2 projection2;
            private readonly TProjection3 projection3;
            private readonly StaticFunc<T2, T3, T4, TResult> projector;

            public ProjectorGeneratorFunction(
                TProjection1 projection1,
                TProjection2 projection2,
                TProjection3 projection3,
                StaticFunc<T2, T3, T4, TResult> projector)
            {
                this.projection1 = projection1;
                this.projection2 = projection2;
                this.projection3 = projection3;
                this.projector = projector;
            }

            public TResult this[T1 value]
            {
                get
                {
                    return projector.Invoke(
                        this.projection1[value],
                        this.projection2[value],
                        this.projection3[value]);
                }
            }

            public Type SourceType
            {
                get { return typeof(T1); }
            }

            public Type ResultType
            {
                get { return typeof(TResult); }
            }

            public object Clone()
            {
                if (this.DependsOnViewport)
                {
                    return new ProjectorGeneratorFunction<T1, T2, T3, T4, TResult, TProjection1, TProjection2, TProjection3>(
                        this.projection1.CloneIfViewportSensitive(),
                        this.projection2.CloneIfViewportSensitive(),
                        this.projection3.CloneIfViewportSensitive(),
                        projector);
                }
                else
                {
                    return this;
                }
            }

            public bool NotifyViewportChanged(IVisibleTableRegion newViewport)
            {
                bool result = false;
                result |= this.projection1.NotifyViewportChanged(newViewport);
                result |= this.projection2.NotifyViewportChanged(newViewport);
                result |= this.projection3.NotifyViewportChanged(newViewport);
                return result;
            }

            public bool DependsOnViewport =>
                this.projection1.DependsOnViewport() ||
                this.projection2.DependsOnViewport() ||
                this.projection3.DependsOnViewport();
        }

        private struct ProjectorGeneratorFunction<T1, T2, T3, T4, T5, TResult, TProjection1, TProjection2, TProjection3, TProjection4>
            : IProjection<T1, TResult>,
              IViewportSensitiveProjection
              where TProjection1 : IProjection<T1, T2>
              where TProjection2 : IProjection<T1, T3>
              where TProjection3 : IProjection<T1, T4>
              where TProjection4 : IProjection<T1, T5>
        {
            private readonly TProjection1 projection1;
            private readonly TProjection2 projection2;
            private readonly TProjection3 projection3;
            private readonly TProjection4 projection4;
            private readonly StaticFunc<T2, T3, T4, T5, TResult> projector;

            public ProjectorGeneratorFunction(
                TProjection1 projection1,
                TProjection2 projection2,
                TProjection3 projection3,
                TProjection4 projection4,
                StaticFunc<T2, T3, T4, T5, TResult> projector)
            {
                this.projection1 = projection1;
                this.projection2 = projection2;
                this.projection3 = projection3;
                this.projection4 = projection4;
                this.projector = projector;
            }

            public TResult this[T1 value]
            {
                get
                {
                    return projector.Invoke(
                        projection1[value],
                        projection2[value],
                        projection3[value],
                        projection4[value]);
                }
            }

            public Type SourceType
            {
                get { return typeof(T1); }
            }

            public Type ResultType
            {
                get { return typeof(TResult); }
            }

            public object Clone()
            {
                if (this.DependsOnViewport)
                {
                    return new ProjectorGeneratorFunction<T1, T2, T3, T4, T5, TResult, TProjection1, TProjection2, TProjection3, TProjection4>(
                        this.projection1.CloneIfViewportSensitive(),
                        this.projection2.CloneIfViewportSensitive(),
                        this.projection3.CloneIfViewportSensitive(),
                        this.projection4.CloneIfViewportSensitive(),
                        projector);
                }
                else
                {
                    return this;
                }
            }

            public bool NotifyViewportChanged(IVisibleTableRegion newViewport)
            {
                bool result = false;
                result |= this.projection1.NotifyViewportChanged(newViewport);
                result |= this.projection2.NotifyViewportChanged(newViewport);
                result |= this.projection3.NotifyViewportChanged(newViewport);
                result |= this.projection4.NotifyViewportChanged(newViewport);
                return result;
            }

            public bool DependsOnViewport =>
                this.projection1.DependsOnViewport() ||
                this.projection2.DependsOnViewport() ||
                this.projection3.DependsOnViewport() ||
                this.projection4.DependsOnViewport();
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance.SDK", "CA1811:AvoidUncalledPrivateCode")]
        private struct SelectGenerator<TResult, T1Generator, T1, T2, TFunction>
            : IProjection<T1, TResult>,
              IViewportSensitiveProjection
              where T1Generator : IProjection<T1, T2>
              where TFunction : IFunc<T1, T2, TResult>
        {
            private T1Generator projection1;
            private TFunction function;

            public SelectGenerator(T1Generator projection1, TFunction function)
            {
                this.projection1 = projection1;
                this.function = function;
            }

            public TResult this[T1 value]
            {
                get
                {
                    return this.function.Invoke(
                        value,
                        this.projection1[value]);
                }
            }

            public Type SourceType
            {
                get { return typeof(T1); }
            }

            public Type ResultType
            {
                get { return typeof(TResult); }
            }

            public object Clone()
            {
                if (this.DependsOnViewport)
                {
                    return new SelectGenerator<TResult, T1Generator, T1, T2, TFunction>(
                        this.projection1.CloneIfViewportSensitive(),
                        this.function);
                }
                else
                {
                    return this; // it's OK for us to 'return this;' because we're a sealed class
                }
            }

            public bool NotifyViewportChanged(IVisibleTableRegion newViewport)
            {
                return this.projection1.NotifyViewportChanged(newViewport);
            }

            public bool DependsOnViewport => this.projection1.DependsOnViewport();
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance.SDK", "CA1811:AvoidUncalledPrivateCode")]
        private struct SelectGenerator<TResult, T1Generator, T2Generator, T1, T2, T3, TFunction>
            : IProjection<T1, TResult>,
              IViewportSensitiveProjection
              where T1Generator : IProjection<T1, T2>
              where T2Generator : IProjection<T1, T3>
              where TFunction : IFunc<T1, T2, T3, TResult>
        {
            private T1Generator projection1;
            private T2Generator projection2;
            private TFunction function;

            public SelectGenerator(T1Generator projection1, T2Generator projection2, TFunction function)
            {
                this.projection1 = projection1;
                this.projection2 = projection2;
                this.function = function;
            }

            public TResult this[T1 value]
            {
                get
                {
                    return this.function.Invoke(
                        value,
                        this.projection1[value],
                        this.projection2[value]);
                }
            }

            public Type SourceType
            {
                get { return typeof(T1); }
            }

            public Type ResultType
            {
                get { return typeof(TResult); }
            }

            public object Clone()
            {
                if (this.DependsOnViewport)
                {
                    return new SelectGenerator<TResult, T1Generator, T2Generator, T1, T2, T3, TFunction>(
                        this.projection1.CloneIfViewportSensitive(),
                        this.projection2.CloneIfViewportSensitive(),
                        this.function);
                }
                else
                {
                    return this;
                }
            }

            public bool NotifyViewportChanged(IVisibleTableRegion newViewport)
            {
                bool result = false;
                result |= this.projection1.NotifyViewportChanged(newViewport);
                result |= this.projection2.NotifyViewportChanged(newViewport);
                return result;
            }

            public bool DependsOnViewport =>
                this.projection1.DependsOnViewport() ||
                this.projection2.DependsOnViewport();
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance.SDK", "CA1811:AvoidUncalledPrivateCode")]
        private struct SelectGenerator<TResult, T1Generator, T2Generator, T3Generator, T1, T2, T3, T4, TFunction>
            : IProjection<T1, TResult>,
              IViewportSensitiveProjection
              where T1Generator : IProjection<T1, T2>
              where T2Generator : IProjection<T1, T3>
              where T3Generator : IProjection<T1, T4>
              where TFunction : IFunc<T1, T2, T3, T4, TResult>
        {
            private T1Generator projection1;
            private T2Generator projection2;
            private T3Generator projection3;
            private TFunction function;

            public SelectGenerator(
                T1Generator projection1,
                T2Generator projection2,
                T3Generator projection3,
                TFunction function)
            {
                this.projection1 = projection1;
                this.projection2 = projection2;
                this.projection3 = projection3;
                this.function = function;
            }

            public TResult this[T1 value]
            {
                get
                {
                    return this.function.Invoke(
                        value,
                        this.projection1[value],
                        this.projection2[value],
                        this.projection3[value]);
                }
            }

            public Type SourceType
            {
                get { return typeof(T1); }
            }

            public Type ResultType
            {
                get { return typeof(TResult); }
            }

            public object Clone()
            {
                if (this.DependsOnViewport)
                {
                    return new SelectGenerator<TResult, T1Generator, T2Generator, T3Generator, T1, T2, T3, T4, TFunction>(
                        this.projection1.CloneIfViewportSensitive(),
                        this.projection2.CloneIfViewportSensitive(),
                        this.projection3.CloneIfViewportSensitive(),
                        this.function);
                }
                else
                {
                    return this;
                }
            }

            public bool NotifyViewportChanged(IVisibleTableRegion newViewport)
            {
                bool result = false;
                result |= this.projection1.NotifyViewportChanged(newViewport);
                result |= this.projection2.NotifyViewportChanged(newViewport);
                result |= this.projection3.NotifyViewportChanged(newViewport);
                return result;
            }

            public bool DependsOnViewport =>
                this.projection1.DependsOnViewport() ||
                this.projection2.DependsOnViewport() ||
                this.projection3.DependsOnViewport();
        }
    }
}
